#!/usr/bin/env python
#
# file: $NEDC_NFC/class/python/nedc_ml_tools_data/nedc_ml_tools_data.py
#
# revision history:
# 20241014 (SM): initial version
#
#
# This class encapsulates data that is to be used for ML Tools.
#------------------------------------------------------------------------------

# import required system modules
#
import os
import numpy as np
import pandas as pd
import copy
from collections import defaultdict

# import required NEDC modules
#
import nedc_debug_tools as ndt

# declare global debug and verbosity objects so we can use them
# in both functions and classes
#
dbgl_g = ndt.Dbgl()
vrbl_g = ndt.Vrbl()

#------------------------------------------------------------------------------
#
# global variables are listed here
#
#------------------------------------------------------------------------------

# set the filename using basename
#
__FILE__ = os.path.basename(__file__)

# define names of distributions so they can be generated by the class
#
TWO_GAUSS = "two_gaussian"
FOUR_GAUSS = "four_gaussian"
OVLP_GAUSS = "overlapping_gaussian"
TWO_ELLIP = "two_ellipses"
FOUR_ELLIP = "four_ellipses"
ROT_ELLIP = "rotated_ellipses"
TORODIAL = "toroidal"
YIN_YANG = "yin_yang"

#------------------------------------------------------------------------------
#
# classes are listed here
#
#------------------------------------------------------------------------------

class MLToolsData:
    """
    Class: MLToolsData

    arguments:
     none

    description:
     This is a class that encapsulates data that can be used with ML Tools.
    """

    def __init__(self, dir_path = "", lndx = 0, nfeats = -1):
        """
        method: constructor

        arguments:
         dir_path: directory path to the file ("")
         lndx: the label index (0)
         nfeats: number of features (-1)

        return:
         none

        description:
         none

        note:
         for nfeats, -1 means that we choose all of the features.
        """
        self.dir_path = dir_path
        self.lndx = lndx
        self.nfeats = nfeats

        self.data = []
        self.labels = []
        self.num_of_classes = 0
        self.mapping_label = {}

        if (dir_path != ""):
            self.load()

    def __repr__(self) -> str:
        return (f"MLToolData({self.dir_path}, label index = {self.lndx}, "
                f"# of features = {self.nfeats if self.nfeats != -1 else 'all'})")

    @classmethod
    def generate_data(cls, dist_name:str, params:dict):
        '''
        function: generate_data

        arguments:
         dist_name: name of the distribution to generate data from
         params: the parameters for the distribution

        return:
         a MLToolsData object populated with the data from the distribution
        
        description:
         generate a MLToolsData object from a sp
        '''

        # generate the data for the distribution
        #
        x, y = DISTS[dist_name](params)

        # create a new MLToolsData object as self. use this because this
        # function is a class method
        #
        self = cls.__new__(cls)

        # directory path to the file (""). there is no file to load since the data
        # is generated
        #
        self.dir_path = ''
        
        # set the label index to 0 for now because I am not sure what this does
        # as of right now
        # TODO: figure out what this variable does
        #
        self.lndx = 0

        # get the features and starting index of the data
        #
        self.nfeats = x.shape[0]

        # set the data and labels as the values that were generated by the distribution
        #
        self.data = np.asarray(x)
        self.labels = np.asarray(y)

        # set the number of classes as the amount of classes in the distribution
        #
        self.num_of_classes = len(set(y))
        
        # set the mapping label to empty for now because I am not sure what this does
        # as of right now
        # TODO: figure out what this variable does
        #
        self.mapping_label = {}

        # return the populated MLToolsData object
        #
        return self
    #
    # end of method

    @classmethod
    def from_data(cls, X, y):
        """
        function: from_imld

        argument:
         imld_data: data that is generated by IMLD

        return:
         a MLToolData object

        description:
         this function is a classmethod that creates a new MLToolData object
         from IMLD's data structure
        """
        self = cls.__new__(cls)
        self.dir_path = ""
        self.lndx = 0
        self.nfeats = -1
        self.num_of_classes = len(set(y))

        # save the data and labels
        #
        self.labels = np.asarray(y)
        self.data = np.asarray(X)

        # create the mapping label
        #
        self.mapping_label = {i: label for i, label in enumerate(set(y))}

        # convert the labels to numbers
        #
        self.labels = self.map_label()

        # save the mapped labels back into ints
        #
        self.labels = np.array(self.labels, dtype = int)

        # return the MLToolsData object
        #
        return self
    #
    # end of method

    @staticmethod
    def is_excel(fname):
        """
        function: is_excel

        arguments:
        fname: filename of the data

        return:
        a boolean value indicating status

        description:
        this function checks if file is an excel spreadsheet.
        """

        # use Pandas to open and parse the file. if this errors,
        # we assume it is a csv file.
        #
        try:
            pd.read_excel(fname)
        except ValueError:
            return False

        # exit gracefully
        #
        return True

    def map_label(self, labels:np.array=None):# -> type[list[_T]] | ndarray | NDArray:

        if labels is None:
            labels = np.array(self.labels)
            unique_labels = np.unique(labels)

        else:
            labels = np.array(labels)
            unique_labels = np.unique(labels)

        for i in range(len(unique_labels)):
            for j in range(len(labels)):
                if labels[j] == unique_labels[i]:
                    labels[j]=i

        return labels

    def load(self):
        """
        function: load_data

        arguments:
        None

        return:
        a list of numpy arrays or None if it fails

        description:
        this function reads data from either an excel sheet or csv file
        and converts it to a dictionary representing the labels and the data.

        Ex: data: {
            "labels": numpy.ndarray[0, 0, 0, 1, 1, 1, 1],
            "data"  : [np.ndarray[01,02,03],
                    [04,05,06],
                    [07,08,09],
                    [60,61,62],
                    [70,71,72],
                    [80,81,82],
                    [90,91,92]]
        }

        The example data above has 2 classes and 3 features.The labels ordering
        and data ordering are the same. The first three vectors are in class "0" and
        the last four are in class "1".

        for nfeats, it will use all the feature from the start to the specified value
        Not counting the label column.

        Ex: if nfeats = 3, then we assume column [0,1,2].

        Ex: If we have [0,1,2,3,4,5] and lndx = 1, nFeatures = 3 then the column
            features would be [0,2,3] since we exclude the column label.

        if the data fails to be loaded, an error is generated and None is returned.
        """

        # display an informational message
        #
        if dbgl_g == ndt.FULL:
            print("%s (line: %s) %s: reading data" %
                (__FILE__, ndt.__LINE__, ndt.__NAME__))

        try:
            if self.is_excel(self.dir_path):
                df = pd.read_excel(self.dir_path, header = None)
            else:
                df = pd.read_csv(self.dir_path, header = None, engine = "c", comment = "#")
        except Exception:
            raise("Error: %s (line: %s) %s: %s (%s)" %
                (__FILE__, ndt.__LINE__, ndt.__NAME__,
                "unknown file or data format", self.dir_path))

        if self.lndx >= df.shape[1]:
            print("Error: %s (line: %s) %s: %s" %
                (__FILE__, ndt.__LINE__, ndt.__NAME__,
                "Label index out of range"))
            return None

        # pop the label column
        #
        label_column = df.pop(self.lndx)

        # clear label map if there was one already
        #
        if not self.mapping_label:
            self.mapping_label.clear()

        # create a label map for readable label to an index.
        #   Note: Since we are sorting, the mapping will not always be in order if
        #         string because sorting uses string comparison
        #
        for ind, val in enumerate(sorted(label_column.unique())):

            if isinstance(val, str):
                self.mapping_label[ind] = val

            # assume any label that is not a string to be a integer
            #
            else:
                self.mapping_label[ind] = int(val)

        if self.nfeats >= df.shape[1] or self.nfeats < -1:
            self.nfeats = -1

        # if the number of feature is specified then we would need to reshape the
        # data frame
        #
        if self.nfeats != -1:
            df = df.iloc[:, : self.nfeats]

        # append the label column at the beginning of the dataframe
        # and rename its column
        #
        df = pd.concat([label_column, df], axis = 1)
        df.columns = list(range(df.shape[1]))

        # set the index of the table using the label column
        #
        df.set_index(df.keys()[0], inplace = True)

        self.data = df.values
        self.labels = df.index.to_numpy()
        self.num_of_classes = len(set(self.labels))


    def sort(self, inplace = False):
        """
        function: sort

        arguments:
         inplace: flag to sort the data inplace (False)

        return:
         If inplace = True -> returns None
         If inplace = False -> returns the sorted data

        description:
        this function sorts the given data model.
        """

        # samples and labels
        #
        samples = self.data
        labels = np.array(self.labels)

        # np.unique() returns a set of unique values that
        # is in order
        #
        uniq_labels = np.unique(labels)

        # empty list to save sorted data snd labels
        #
        sorted_data = []
        sorted_labels = []

        # loop through the unique labels
        #
        for element in uniq_labels:

            # empty list to save class labels and class data
            #
            class_data = []
            class_labels = []

            # loop through the len labels and compare labels with unique label
            #
            for i in range(len(labels)):
                if labels[i] == element:
                    class_data.append(samples[i])
                    class_labels.append(labels[i])

            sorted_data.extend(class_data)
            sorted_labels.extend(class_labels)

        sorted_data = np.array(sorted_data)
        sorted_labels = np.array(sorted_labels)

        if inplace:
            self.data = sorted_data
            self.labels = sorted_labels

            return None
        else:

            MLToolDataNew = copy.deepcopy(self)
            MLToolDataNew.data = sorted_data
            MLToolDataNew.labels = sorted_labels

            return MLToolDataNew

    def write(self, oname, label):
        """
        function: write

        argument:
         oname: the output file name
         label: the label to write

        return:
        boolean indicating the status

        description:
        this function writes the data with new label to a file
        """

        d = pd.DataFrame(self.data)

        #  add the label to the first column of the file
        #
        try:
            d.insert(0, column = "labels", value = label)
        except ValueError:
            print("Error: %s (line: %s) %s: %s" %
                (__FILE__, ndt.__LINE__, ndt.__NAME__,
                "Labels column already existed within the data"))
            return False

        if self.is_excel(self.dir_path):
            d.to_excel(oname)
        else:
            d.to_csv(oname, index = False, header = False)

        return True

    def group_by_class(self):
        """
        function: group_by_class

        argument:
         none

        return:
         group data

        description:
        this function group the data by the label
        """
        group_data = defaultdict(list)

        for label, data in zip(self.labels, self.data):
            group_data[label].append(data)

        return group_data

#
# end of dataclass

def generate_data(dist_name:str, params:dict):
    '''
    function: generate_data

    arguments:
     dist_name: name of the distribution to generate data from
     params: the parameters for the distribution

    return:
     a MLToolsData object populated with the data from the distribution
        
    description:
     generate a MLToolsData object from a sp
    '''

    # generate the data for the distribution
    #
    labels, x, y = DISTS[dist_name](params)

    return labels, x, y

def generate_two_gaussian(params:dict) -> tuple:
    '''
    function generate_two_gaussian

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'npts1'  (int)     : the number of points to generate
                             'mean1' (list)     : the mean values for the two toroidal distributions
                             'cov1'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts2'  (int)     : the number of points to generate
                             'mean2' (list)     : the mean values for the two toroidal distributions
                             'cov2'  (2D list)  : the covariance matrices for the two toroidal distributions
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate two gaussian masses, each of different labels.
    '''

    # get parameters
    #
    npts1, mean1, cov1 = params['npts1'], np.ravel(params['mean1']), params['cov1']
    npts2, mean2, cov2 = params['npts2'], np.ravel(params['mean2']), params['cov2']
    
    # gaussian distribution for class 0
    #
    class_0_data = np.random.multivariate_normal(mean1, cov1, npts1)
    class_0_labels = ['Class0'] * npts1  # Label for class 0
    
    # gaussian distribution for class 1
    #
    class_1_data = np.random.multivariate_normal(mean2, cov2, npts2)
    class_1_labels = ['Class1'] * npts2  # Label for class 1
    
    # concatenate data w labels
    #
    X = np.vstack((class_0_data, class_1_data))
    labels = class_0_labels + class_1_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of method

def generate_four_gaussian(params:dict) -> tuple:
    '''
    function generate_four_gaussian

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'npts1'  (int)     : the number of points to generate
                             'mean1' (list)     : the mean values for the two toroidal distributions
                             'cov1'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts2'  (int)     : the number of points to generate
                             'mean2' (list)     : the mean values for the two toroidal distributions
                             'cov2'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts3'  (int)     : the number of points to generate
                             'mean3' (list)     : the mean values for the two toroidal distributions
                             'cov3'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts4'  (int)     : the number of points to generate
                             'mean4' (list)     : the mean values for the two toroidal distributions
                             'cov4'  (2D list)  : the covariance matrices for the two toroidal distributions
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate four gaussian masses, each of different labels.
    '''

    # get parameters
    npts1, mean1, cov1 = params['npts1'], np.ravel(params['mean1']), params['cov1']
    npts2, mean2, cov2 = params['npts2'], np.ravel(params['mean2']), params['cov2']
    npts3, mean3, cov3 = params['npts3'], np.ravel(params['mean3']), params['cov3']
    npts4, mean4, cov4 = params['npts4'], np.ravel(params['mean4']), params['cov4']
    
    # gaussian distributions for each class
    class_0_data = np.random.multivariate_normal(mean1, cov1, npts1)
    class_0_labels = ['Class0'] * npts1  # Label for class 0
    
    class_1_data = np.random.multivariate_normal(mean2, cov2, npts2)
    class_1_labels = ['Class1'] * npts2  # Label for class 1
    
    class_2_data = np.random.multivariate_normal(mean3, cov3, npts3)
    class_2_labels = ['Class2'] * npts3  # Label for class 2
    
    class_3_data = np.random.multivariate_normal(mean4, cov4, npts4)
    class_3_labels = ['Class3'] * npts4  # Label for class 3
    
    # concatenate data w labels
    X = np.vstack((class_0_data, class_1_data, class_2_data, class_3_data))
    labels = class_0_labels + class_1_labels + class_2_labels + class_3_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of method

def generate_ovlp_gaussian(params:dict) -> tuple:
    '''
    function generate_ovlp_gaussian

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'npts1'  (int)     : the number of points to generate
                             'mean1' (list)     : the mean values for the two toroidal distributions
                             'cov1'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts2'  (int)     : the number of points to generate
                             'mean2' (list)     : the mean values for the two toroidal distributions
                             'cov2'  (2D list)  : the covariance matrices for the two toroidal distributions
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate two gaussian masses, overlapping each other.
    '''

    # get parameters
    #
    npts1, mean1, cov1 = params['npts1'], np.ravel(params['mean1']), params['cov1']
    npts2, mean2, cov2 = params['npts2'], np.ravel(params['mean2']), params['cov2']
    
    # gaussian distributions for each class
    #
    class_0_data = np.random.multivariate_normal(mean1, cov1, npts1)
    class_0_labels = ['Class0'] * npts1  # Label for class 0
    
    class_1_data = np.random.multivariate_normal(mean2, cov2, npts2)
    class_1_labels = ['Class1'] * npts2  # Label for class 1
    
    # concatenate data w labels
    #
    X = np.vstack((class_0_data, class_1_data))
    labels = class_0_labels + class_1_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of method

def generate_two_ellipses(params:dict) -> tuple:
    '''
    function generate_two_ellipses

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'npts1'  (int)     : the number of points to generate
                             'mean1' (list)     : the mean values for the two toroidal distributions
                             'cov1'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts2'  (int)     : the number of points to generate
                             'mean2' (list)     : the mean values for the two toroidal distributions
                             'cov2'  (2D list)  : the covariance matrices for the two toroidal distributions
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate two ellipses masses, each of different labels.
    '''

    # get parameters
    #
    npts1, mean1, cov1 = params['npts1'],  np.ravel(params['mean1']), params['cov1']
    npts2, mean2, cov2 = params['npts2'],  np.ravel(params['mean2']), params['cov2']
    
    # generate data for class 0
    #
    class_0_data = np.random.multivariate_normal(mean1, cov1, npts1)
    class_0_labels = ['Class0'] * npts1  # Label for class 0
    
    # generate data for class 1
    #
    class_1_data = np.random.multivariate_normal(mean2, cov2, npts2)
    class_1_labels = ['Class1'] * npts2  # Label for class 1
    
    # concatenate data w labels
    #
    X = np.vstack((class_0_data, class_1_data))
    labels = class_0_labels + class_1_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of method

def generate_four_ellipses(params:dict) -> tuple:
    '''
    function generate_four_ellipses

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'npts1'  (int)     : the number of points to generate
                             'mean1' (list)     : the mean values for the two toroidal distributions
                             'cov1'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts2'  (int)     : the number of points to generate
                             'mean2' (list)     : the mean values for the two toroidal distributions
                             'cov2'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts3'  (int)     : the number of points to generate
                             'mean3' (list)     : the mean values for the two toroidal distributions
                             'cov3'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts4'  (int)     : the number of points to generate
                             'mean4' (list)     : the mean values for the two toroidal distributions
                             'cov4'  (2D list)  : the covariance matrices for the two toroidal distributions
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate four ellipses masses, each of different labels.
    '''

    # get parameters
    npts1, mean1, cov1 = params['npts1'], np.ravel(params['mean1']), params['cov1']
    npts2, mean2, cov2 = params['npts2'], np.ravel(params['mean2']), params['cov2']
    npts3, mean3, cov3 = params['npts3'], np.ravel(params['mean3']), params['cov3']
    npts4, mean4, cov4 = params['npts4'], np.ravel(params['mean4']), params['cov4']
    
    # gaussian distributions for each class
    class_0_data = np.random.multivariate_normal(mean1, cov1, npts1)
    class_0_labels = ['Class0'] * npts1  # Label for class 0
    
    class_1_data = np.random.multivariate_normal(mean2, cov2, npts2)
    class_1_labels = ['Class1'] * npts2  # Label for class 1
    
    class_2_data = np.random.multivariate_normal(mean3, cov3, npts3)
    class_2_labels = ['Class2'] * npts3  # Label for class 2
    
    class_3_data = np.random.multivariate_normal(mean4, cov4, npts4)
    class_3_labels = ['Class3'] * npts4  # Label for class 3
    
    # concatenate data w labels
    X = np.vstack((class_0_data, class_1_data, class_2_data, class_3_data))
    labels = class_0_labels + class_1_labels + class_2_labels + class_3_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y

#
# end of method

def generate_rotated_ellipses(params:dict) -> tuple:
    '''
    function generate_rotated_ellipses

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'npts1'  (int)     : the number of points to generate
                             'mean1' (list)     : the mean values for the two toroidal distributions
                             'cov1'  (2D list)  : the covariance matrices for the two toroidal distributions
                             'npts2'  (int)     : the number of points to generate
                             'mean2' (list)     : the mean values for the two toroidal distributions
                             'cov2'  (2D list)  : the covariance matrices for the two toroidal distributions
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate two rotated ellipses masses, each of different labels.
    '''

    # get parameters
    #
    npts1, mean1, cov1 = params['npts1'],  np.ravel(params['mean1']), params['cov1']
    npts2, mean2, cov2 = params['npts2'],  np.ravel(params['mean2']), params['cov2']
    
    # generate data for class 0
    #
    class_0_data = np.random.multivariate_normal(mean1, cov1, npts1)
    class_0_labels = ['Class0'] * npts1  # Label for class 0
    
    # generate data for class 1
    #
    class_1_data = np.random.multivariate_normal(mean2, cov2, npts2)
    class_1_labels = ['Class1'] * npts2  # Label for class 1
    
    # concatenate data w labels
    #
    X = np.vstack((class_0_data, class_1_data))
    labels = class_0_labels + class_1_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of method

def generate_toroidal(params:dict) -> tuple:
    '''
    function generate_toroidal

    args:
     params (dict): a dictionary containing the parameters for the distribution.
                    params = {
                             'mean' (list)      : the mean values for the two toroidal distributions
                             'cov'  (2D list)   : the covariance matrices for the two toroidal distributions
                             'npts_mass' (int)  : the number of points to generate
                             'npts_ring' (int)  : the number of points to generate for the ring
                             'inner_rad' (float): 
                             'outer_rad' (float):
                             }

    return:
     X (np.ndarray): a 2D array containing all of the data points generated.
                     should contain the data for both classes.
     y (list): a list containing the labels for each data point in X

    description:
     generate two toroidal masses, each of different labels.
    '''

    # get parameters
    #
    mean = np.ravel(params['mean'])
    cov = params['cov']
    npts_mass = params['npts_mass']
    npts_ring = params['npts_ring']
    inner_rad = params['inner_rad']
    outer_rad = params['outer_rad']

    # create data points for mass (class 1)
    #
    class_1_data = np.random.multivariate_normal(mean, cov, npts_mass)
    class_1_labels = ['Class1'] * npts_mass

    # create data points for ring (class 0)
    #
    ring_radius = np.random.uniform(inner_rad, outer_rad, npts_ring)
    angle = np.linspace(0,2 * np.pi, npts_ring)
    class_0_data = np.array([mean[0] + ring_radius * np.cos(angle),
                         mean[1] + ring_radius * np.sin(angle)]).T
    class_0_labels = ['Class0'] * npts_ring

    # concatenate data w labels
    #
    X = np.vstack((class_0_data, class_1_data))
    labels = class_0_labels + class_1_labels
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of method

def generate_yin_yang(params: dict) -> tuple:

    # Get parameters
    #
    radius = params['radius']
    n_yin = params['npts_yin']
    n_yang = params['npts_yang']
    overlap = params['ovlp']

    # Boundary, mean, and standard deviation of plot
    #
    xmean = 0
    ymean = 0
    stddev_center = 1.5 * (radius) / 2

    # Calculate radii for yin-yang regions
    #
    radius1 = radius / 2
    radius2 = radius / 4

    # Create empty lists for storing points
    #
    yin = []
    yang = []

    # Counters to track generated points for each class
    #
    n_yin_counter = 0
    n_yang_counter = 0

    # Generate points for yin and yang
    #
    while n_yin_counter < n_yin or n_yang_counter < n_yang:
        xpt = np.random.normal(xmean, stddev_center)
        ypt = np.random.normal(ymean, stddev_center)

        # Calculate distances for each generated point
        #
        distance1 = np.sqrt(xpt ** 2 + ypt ** 2)
        distance2 = np.sqrt(xpt ** 2 + (ypt + radius2) ** 2)
        distance3 = np.sqrt(xpt ** 2 + (ypt - radius2) ** 2)

        # Determine point class based on position and distances
        #
        if distance1 <= radius1:
            if -radius1 <= xpt <= 0:
                if ((distance1 <= radius1 or distance2 <= radius2) and distance3 > radius2):
                    if n_yin_counter < n_yin:
                        yin.append([xpt, ypt])
                        n_yin_counter += 1
                elif n_yang_counter < n_yang:
                    yang.append([xpt, ypt])
                    n_yang_counter += 1
            elif 0 < xpt <= radius1:
                if ((distance1 <= radius1 or distance3 <= radius2) and distance2 > radius2):
                    if n_yang_counter < n_yang:
                        yang.append([xpt, ypt])
                        n_yang_counter += 1
                elif n_yin_counter < n_yin:
                    yin.append([xpt, ypt])
                    n_yin_counter += 1

    # Translate yin and yang points to center them on the plot
    #
    yin = np.array(yin) + np.array([0, overlap * radius2])
    yang = np.array(yang) - np.array([0, overlap * radius2])

    # Return generated data as a dictionary
    # Combine the yin and yang classes and create the labels
    #
    X = np.concatenate((yin, yang), axis=0)
    labels = ['Class0'] * n_yin + ['Class1'] * n_yang
    
    x = X[:,0]
    y = X[:,1]

    # exit gracefully
    #
    return labels, x, y
#
# end of function

#------------------------------------------------------------------------------
#
# definitions dependent on the above classes go here
#
#------------------------------------------------------------------------------

# define variables to configure the machine learning algorithms
#
DISTS = {TWO_GAUSS : generate_two_gaussian,
         FOUR_GAUSS: generate_four_gaussian,
         OVLP_GAUSS: generate_ovlp_gaussian,
         TWO_ELLIP : generate_two_ellipses,
         FOUR_ELLIP: generate_four_ellipses,
         ROT_ELLIP : generate_rotated_ellipses,
         TORODIAL  : generate_toroidal,
         YIN_YANG  : generate_yin_yang}
#
# end of file